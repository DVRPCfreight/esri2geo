{"ts":1342178799664,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"function toGeoJSON(data){\n    var outPut = { \"type\": \"FeatureCollection\",\n  \"features\": []};\n    var fl = data.features.length;\n    var i = 0;\n    while(fl>i){\n     var ft = data.features[i];\n     var outFT = {\n            \"type\": \"Feature\",\n            \"properties\":ft.attributes\n        };\n        if(ft.geometry.x){\n          outFT.geometry=point(ft.geometry);\n        }else if(ft.geometry.points){\n            outFT.geometry=points(ft.geometry);\n            }else if(ft.geometry.paths){\n         outFT.geometry=line(ft.geometry);\n        }else if(ft.geometry.rings){\n           outFT.geometry=poly(ft.geometry);  \n        }\n        \n     outPut.features.push(outFT);\n     i++;\n    }\nfunction point(geometry){\n    return {\"type\": \"Point\",\"coordinates\": [geometry.x,geometry.y]};    \n}\nfunction points(geometry){\n    if(geometry.points.length===1){\n        return {\"type\": \"Point\",\"coordinates\": geometry.points[0]};\n    }else{\n        return { \"type\": \"MultiPoint\",\"coordinates\":geometry.points}; \n    }\n}\nfunction line(geometry){\n    if(geometry.paths.length===1){\n        return {\"type\": \"LineString\",\"coordinates\": geometry.paths[0]};\n    }else{\n        return { \"type\": \"MultiLineString\",\"coordinates\":geometry.paths}; \n    }\n}\nfunction poly(geometry){\n    if(geometry.rings.length===1){\n        return {\"type\": \"Polygon\",\"coordinates\": geometry.rings};\n    }else{\n        var r = [];\n        var l = geometry.rings.length;\n        var ii = 0;\n        while(l>ii){\n         r.push([geometry.rings[ii]]);\n         ii++;\n        }\n        return { \"type\": \"MultiPolygon\",\"coordinates\":r}; \n    }\n}\nfunction c(a){\n var l = a.length-1;\n var i = 0;\n var o=0;\n\n while(l>i){\n o+=(a[i][0]*a[i+1][1]-a[i+1][0]*a[i][1]);\n   \n     i++;\n }\n    return o<=0;\n}  \n    \nreturn outPut;  \n}\n\n"]],"start1":0,"start2":0,"length1":0,"length2":1781}]],"length":1781}
{"contributors":[],"silentsave":false,"ts":1342796065050,"patch":[[{"diffs":[[0,"SON(data"],[1,",cb"],[0,"){"],[1,"\r"],[0,"\n    var"]],"start1":15,"start2":15,"length1":18,"length2":22},{"diffs":[[0,"ection\","],[1,"\r"],[0,"\n  \"feat"]],"start1":69,"start2":69,"length1":16,"length2":17},{"diffs":[[0,"s\": []};"],[1,"\r"],[0,"\n    var"]],"start1":89,"start2":89,"length1":16,"length2":17},{"diffs":[[0,"ures.length;"],[1,"\r"],[0,"\n    var i ="]],"start1":121,"start2":121,"length1":24,"length2":25},{"diffs":[[0,"  var i = 0;"],[1,"\r"],[0,"\n    while(f"]],"start1":137,"start2":137,"length1":24,"length2":25},{"diffs":[[0,"e(fl>i){"],[1,"\r"],[0,"\n     va"]],"start1":159,"start2":159,"length1":16,"length2":17},{"diffs":[[0,"ures[i];"],[1,"\r\n/* as only ESRI based products care if all the features are the same type of geometry, check for geometry type at a feature level*/\r"],[0,"\n     va"]],"start1":192,"start2":192,"length1":16,"length2":150},{"diffs":[[0,"utFT = {"],[1,"\r"],[0,"\n       "]],"start1":345,"start2":345,"length1":16,"length2":17},{"diffs":[[0,"eature\","],[1,"\r"],[0,"\n       "]],"start1":377,"start2":377,"length1":16,"length2":17},{"diffs":[[0,"tributes"],[1,"\r"],[0,"\n       "]],"start1":417,"start2":417,"length1":16,"length2":17},{"diffs":[[0,"      };"],[1,"\r"],[0,"\n       "]],"start1":429,"start2":429,"length1":16,"length2":17},{"diffs":[[0,"etry.x){"],[-1,"\n  "],[1,"\r\n//check if it's a point\r\n"],[0,"        "],[1,"  "],[0,"outFT.ge"]],"start1":457,"start2":457,"length1":27,"length2":53},{"diffs":[[0,"nt(ft.geometry);"],[1,"\r"],[0,"\n        }else i"]],"start1":520,"start2":520,"length1":32,"length2":33},{"diffs":[[0,"points){"],[-1,"\n  "],[1,"\r\n//check if it is a multipoint\r\n"],[0,"        "]],"start1":567,"start2":567,"length1":19,"length2":49},{"diffs":[[0,"oint\r\n          "],[1,"  "],[0,"outFT.geometry=p"]],"start1":602,"start2":602,"length1":32,"length2":34},{"diffs":[[0,"ts(ft.geometry);"],[1,"\r"],[0,"\n            }el"]],"start1":639,"start2":639,"length1":32,"length2":33},{"diffs":[[0,".paths){"],[1,"\r\n//check if a line (or \"ARC\" in ESRI terms)\r"],[0,"\n       "]],"start1":689,"start2":689,"length1":16,"length2":61},{"diffs":[[0,"ometry);"],[1,"\r"],[0,"\n       "]],"start1":777,"start2":777,"length1":16,"length2":17},{"diffs":[[0,".rings){"],[1,"\r\n//check if a poly.\r"],[0,"\n       "]],"start1":815,"start2":815,"length1":16,"length2":37},{"diffs":[[0,"etry);  "],[1,"\r"],[0,"\n       "]],"start1":883,"start2":883,"length1":16,"length2":17},{"diffs":[[0,"y);  \r\n        }"],[1,"\r"],[0,"\n        \n     o"]],"start1":886,"start2":886,"length1":32,"length2":33},{"diffs":[[0,"        "],[1,"\r"],[0,"\n     ou"]],"start1":904,"start2":904,"length1":16,"length2":17},{"diffs":[[0,"(outFT);"],[1,"\r"],[0,"\n     i+"]],"start1":939,"start2":939,"length1":16,"length2":17},{"diffs":[[0,"    i++;"],[1,"\r"],[0,"\n    }"],[1,"\r"],[0,"\nfunctio"]],"start1":950,"start2":950,"length1":22,"length2":24},{"diffs":[[0,"t(geometry){"],[1,"\r\n//this one is easy\r"],[0,"\n    return "]],"start1":980,"start2":980,"length1":24,"length2":45},{"diffs":[[0,"y]};    "],[1,"\r"],[0,"\n}"],[1,"\r"],[0,"\nfunctio"]],"start1":1078,"start2":1078,"length1":18,"length2":20},{"diffs":[[0,"oints(geometry){"],[1,"\r\n//checks if the multipoint only has one point, if so exports as point instead\r"],[0,"\n    if(geometry"]],"start1":1101,"start2":1101,"length1":32,"length2":112},{"diffs":[[0,"nts.length===1){"],[1,"\r"],[0,"\n        return "]],"start1":1217,"start2":1217,"length1":32,"length2":33},{"diffs":[[0,".points[0]};"],[1,"\r"],[0,"\n    }else{\n"]],"start1":1290,"start2":1290,"length1":24,"length2":25},{"diffs":[[0,"0]};\r\n    }else{"],[1,"\r"],[0,"\n        return "]],"start1":1298,"start2":1298,"length1":32,"length2":33},{"diffs":[[0,"ry.points}; "],[1,"\r"],[0,"\n    }"],[1,"\r"],[0,"\n}"],[1,"\r"],[0,"\nfunction li"]],"start1":1374,"start2":1374,"length1":32,"length2":35},{"diffs":[[0," line(geometry){"],[1,"\r\n//checks if their are multiple paths or just one\r"],[0,"\n    if(geometry"]],"start1":1406,"start2":1406,"length1":32,"length2":83},{"diffs":[[0,"ths.length===1){"],[1,"\r"],[0,"\n        return "]],"start1":1492,"start2":1492,"length1":32,"length2":33},{"diffs":[[0,"ths[0]};"],[1,"\r"],[0,"\n    }el"]],"start1":1573,"start2":1573,"length1":16,"length2":17},{"diffs":[[0,"0]};\r\n    }else{"],[1,"\r"],[0,"\n        return "]],"start1":1577,"start2":1577,"length1":32,"length2":33},{"diffs":[[0,"paths}; "],[1,"\r"],[0,"\n    }"],[1,"\r"],[0,"\n}"],[1,"\r"],[0,"\nfunctio"]],"start1":1661,"start2":1661,"length1":24,"length2":27},{"diffs":[[0,"ometry){"],[1,"\r\n//first we check for some easy cases, like if their is only one ring\r"],[0,"\n    if("]],"start1":1697,"start2":1697,"length1":16,"length2":87},{"diffs":[[0,"th===1){"],[1,"\r"],[0,"\n       "]],"start1":1803,"start2":1803,"length1":16,"length2":17},{"diffs":[[0,".rings};"],[1,"\r"],[0,"\n    }el"]],"start1":1870,"start2":1870,"length1":16,"length2":17},{"diffs":[[0,"lse{"],[-1,"\n        var r = ["],[1,"\r\n/*if it isn't that easy then we have to start checking ring direction, basically the ring goes clockwise its part of the polygon, if it goes counterclockwise it is a hole in the polygon, but geojson does it by haveing an array with the first element be the polygons and the next elements being holes in it*/\r\n        var ccc= dP(geometry.rings);\r\n        var d = ccc[0"],[0,"];"],[1,"\r"],[0,"\n   "]],"start1":1886,"start2":1886,"length1":28,"length2":381},{"diffs":[[0,"var "],[-1,"l = geometry.rings"],[1,"dd = ccc[1];\r\n        var r=[];\r\n        if(dd.length===0){\r\n/*if their are no holes we don't need to worry about this, but do need to stuck each ring inside its own array*/\r\n            var l2 = d"],[0,".length;"],[-1,"\n"],[1,"\r\n  "],[0,"        "],[1,"  "],[0,"var i"],[-1,"i"],[1,"3"],[0," = 0;"],[-1,"\n"],[1,"\r\n    "],[0,"    "]],"start1":2272,"start2":2272,"length1":55,"length2":244},{"diffs":[[0,"le(l"],[1,"2"],[0,">i"],[-1,"i){\n"],[1,"3){\r\n    "],[0,"    "]],"start1":2523,"start2":2523,"length1":14,"length2":20},{"diffs":[[0,"sh(["],[-1,"geometry.rings[ii]]);\n         ii++;\n        }\n        return { \"type\": \"MultiPolygon\",\"coordinates\":r}; \n    }"],[1,"d[i3]]);   \r\n            }\r\n            return { \"type\": \"MultiPolygon\",\"coordinates\":r}; \r\n        }else if(d.length===1){\r\n/*if their is only one clockwise ring then we know all holes are in that poly*/\r\n            dd.unshift(d[0]);\r\n            return {\"type\": \"Polygon\",\"coordinates\": dd};\r\n            \r\n        }else{\r\n/*if their are multiple rings and holes we have no way of knowing which belong to which without looking at it specially, so just dump the coordinates and add  a hole field, this may cause errors*/\r\n            return { \"type\": \"MultiPolygon\",\"coordinates\":d, \"holes\":dd};\r\n        }  \r\n    }\r\n}\r\nfunction dP(a){\r\n//returns an array of 2 arrays, the first being all the clockwise ones, the second counter clockwise\r\n    var d = [];\r\n        var dd =[];\r\n        var l = a.length;\r\n        var ii = 0;\r\n        while(l>ii){\r\n            if(c(a[ii])){\r\n                d.push(a[ii]);\r\n            }else{\r\n             dd.push(a[ii]);\r\n            }\r\n         ii++;\r\n        }\r\n    return [d,dd];\r"],[0,"\n}"],[1,"\r"],[0,"\nfun"]],"start1":2552,"start2":2552,"length1":121,"length2":1030},{"diffs":[[0,"on c(a){"],[1,"\r\n//return true if clockwise\r"],[0,"\n var l "]],"start1":3585,"start2":3585,"length1":16,"length2":45},{"diffs":[[0,"ength-1;"],[1,"\r"],[0,"\n var i "]],"start1":3635,"start2":3635,"length1":16,"length2":17},{"diffs":[[0,"r i = 0;"],[1,"\r"],[0,"\n var o="]],"start1":3648,"start2":3648,"length1":16,"length2":17},{"diffs":[[0,"var o=0;"],[-1,"\n"],[1,"\r\n\r"],[0,"\n while("]],"start1":3659,"start2":3659,"length1":17,"length2":19},{"diffs":[[0,"le(l>i){"],[1,"\r"],[0,"\n o+=(a["]],"start1":3675,"start2":3675,"length1":16,"length2":17},{"diffs":[[0,"[i][1]);"],[1,"\r"],[0,"\n   "],[1,"\r"],[0,"\n     i+"]],"start1":3719,"start2":3719,"length1":20,"length2":22},{"diffs":[[0,"i++;"],[1,"\r"],[0,"\n }"],[1,"\r"],[0,"\n   "]],"start1":3739,"start2":3739,"length1":11,"length2":13},{"diffs":[[0,"<=0;"],[1,"\r"],[0,"\n}  "],[-1,"\n    "],[1,"\r\nif(cb){\r\n cb(outPut)\r\n}else{\r"],[0,"\nret"]],"start1":3761,"start2":3761,"length1":17,"length2":44},{"diffs":[[0,"t;  "],[1,"\r"],[0,"\n}"],[-1,"\n\n"],[1,"\r\n}"]],"start1":3814,"start2":3814,"length1":8,"length2":10}]],"length":3824,"saved":false}
{"contributors":[],"silentsave":false,"ts":1343397710076,"patch":[[{"diffs":[[0,"        };\r\n"],[1,"        if(ft.attributes.OBJECTID){\r\n         outFT.id=ft.attributes.OBJECTID;\r\n        }\r\n"],[0,"        if(f"]],"start1":427,"start2":427,"length1":24,"length2":115}]],"length":3915,"saved":false}
